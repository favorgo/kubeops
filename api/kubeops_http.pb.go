// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.0.5

package api

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type KubeOpsApiHTTPServer interface {
	CreateProject(context.Context, *CreateProjectRequest) (*CreateProjectResponse, error)
	GetInventory(context.Context, *GetInventoryRequest) (*GetInventoryResponse, error)
	GetResult(context.Context, *GetResultRequest) (*GetResultResponse, error)
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	ListProject(context.Context, *ListProjectRequest) (*ListProjectResponse, error)
	ListResult(context.Context, *ListResultRequest) (*ListResultResponse, error)
	RunAdhoc(context.Context, *RunAdhocRequest) (*RunAdhocResult, error)
	RunPlaybook(context.Context, *RunPlaybookRequest) (*RunPlaybookResult, error)
}

func RegisterKubeOpsApiHTTPServer(s *http.Server, srv KubeOpsApiHTTPServer) {
	r := s.Route("/")
	r.GET("/kubeops/project/{name}", _KubeOpsApi_CreateProject0_HTTP_Handler(srv))
	r.GET("/kubeops/project", _KubeOpsApi_ListProject0_HTTP_Handler(srv))
	r.GET("/kubeops/inventory", _KubeOpsApi_GetInventory0_HTTP_Handler(srv))
	r.POST("/kubeops/playbook", _KubeOpsApi_RunPlaybook0_HTTP_Handler(srv))
	r.POST("/kubeops/Adhoc", _KubeOpsApi_RunAdhoc0_HTTP_Handler(srv))
	r.GET("/kubeops/result/{taskId}", _KubeOpsApi_GetResult0_HTTP_Handler(srv))
	r.GET("/kubeops/result", _KubeOpsApi_ListResult0_HTTP_Handler(srv))
	r.GET("/kubeops/healthz", _KubeOpsApi_Health0_HTTP_Handler(srv))
}

func _KubeOpsApi_CreateProject0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateProjectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/CreateProject")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateProject(ctx, req.(*CreateProjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateProjectResponse)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_ListProject0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListProjectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/ListProject")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListProject(ctx, req.(*ListProjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListProjectResponse)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_GetInventory0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetInventoryRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/GetInventory")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetInventory(ctx, req.(*GetInventoryRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetInventoryResponse)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_RunPlaybook0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunPlaybookRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/RunPlaybook")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunPlaybook(ctx, req.(*RunPlaybookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunPlaybookResult)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_RunAdhoc0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunAdhocRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/RunAdhoc")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunAdhoc(ctx, req.(*RunAdhocRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunAdhocResult)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_GetResult0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetResultRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/GetResult")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetResult(ctx, req.(*GetResultRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetResultResponse)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_ListResult0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListResultRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/ListResult")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListResult(ctx, req.(*ListResultRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListResultResponse)
		return ctx.Result(200, reply)
	}
}

func _KubeOpsApi_Health0_HTTP_Handler(srv KubeOpsApiHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HealthRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.KubeOpsApi/Health")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Health(ctx, req.(*HealthRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HealthResponse)
		return ctx.Result(200, reply)
	}
}

type KubeOpsApiHTTPClient interface {
	CreateProject(ctx context.Context, req *CreateProjectRequest, opts ...http.CallOption) (rsp *CreateProjectResponse, err error)
	GetInventory(ctx context.Context, req *GetInventoryRequest, opts ...http.CallOption) (rsp *GetInventoryResponse, err error)
	GetResult(ctx context.Context, req *GetResultRequest, opts ...http.CallOption) (rsp *GetResultResponse, err error)
	Health(ctx context.Context, req *HealthRequest, opts ...http.CallOption) (rsp *HealthResponse, err error)
	ListProject(ctx context.Context, req *ListProjectRequest, opts ...http.CallOption) (rsp *ListProjectResponse, err error)
	ListResult(ctx context.Context, req *ListResultRequest, opts ...http.CallOption) (rsp *ListResultResponse, err error)
	RunAdhoc(ctx context.Context, req *RunAdhocRequest, opts ...http.CallOption) (rsp *RunAdhocResult, err error)
	RunPlaybook(ctx context.Context, req *RunPlaybookRequest, opts ...http.CallOption) (rsp *RunPlaybookResult, err error)
}

type KubeOpsApiHTTPClientImpl struct {
	cc *http.Client
}

func NewKubeOpsApiHTTPClient(client *http.Client) KubeOpsApiHTTPClient {
	return &KubeOpsApiHTTPClientImpl{client}
}

func (c *KubeOpsApiHTTPClientImpl) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...http.CallOption) (*CreateProjectResponse, error) {
	var out CreateProjectResponse
	pattern := "/kubeops/project/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/CreateProject"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) GetInventory(ctx context.Context, in *GetInventoryRequest, opts ...http.CallOption) (*GetInventoryResponse, error) {
	var out GetInventoryResponse
	pattern := "/kubeops/inventory"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/GetInventory"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) GetResult(ctx context.Context, in *GetResultRequest, opts ...http.CallOption) (*GetResultResponse, error) {
	var out GetResultResponse
	pattern := "/kubeops/result/{taskId}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/GetResult"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) Health(ctx context.Context, in *HealthRequest, opts ...http.CallOption) (*HealthResponse, error) {
	var out HealthResponse
	pattern := "/kubeops/healthz"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/Health"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) ListProject(ctx context.Context, in *ListProjectRequest, opts ...http.CallOption) (*ListProjectResponse, error) {
	var out ListProjectResponse
	pattern := "/kubeops/project"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/ListProject"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) ListResult(ctx context.Context, in *ListResultRequest, opts ...http.CallOption) (*ListResultResponse, error) {
	var out ListResultResponse
	pattern := "/kubeops/result"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.KubeOpsApi/ListResult"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) RunAdhoc(ctx context.Context, in *RunAdhocRequest, opts ...http.CallOption) (*RunAdhocResult, error) {
	var out RunAdhocResult
	pattern := "/kubeops/Adhoc"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.KubeOpsApi/RunAdhoc"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *KubeOpsApiHTTPClientImpl) RunPlaybook(ctx context.Context, in *RunPlaybookRequest, opts ...http.CallOption) (*RunPlaybookResult, error) {
	var out RunPlaybookResult
	pattern := "/kubeops/playbook"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.KubeOpsApi/RunPlaybook"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
